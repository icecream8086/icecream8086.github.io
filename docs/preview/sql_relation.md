---
title: 关系代数-SQL对照表
createTime: 2025/11/03 01:20:41
permalink: /article/7n1ibejv/
---
1. **符号像天书**：`π`、`σ`、`∞`… 这些希腊符号对我们来说太陌生了，远没有SQL语句里的 `SELECT`、`FROM`、`WHERE` 来得直观。
2. **感觉离实际很远**：“我直接写SQL就能查数据，为什么还要学这个？” 这是关系代数是SQL的“底层逻辑”，理解了它，你才能更懂SQL，写出更好的查询。

---

### **关系代数与SQL对照全览表**

| 类别 | 关系代数符号 | 读法 | 对应SQL子句 | 比喻 | 功能说明与数学表示 |
| :--- | :--- | :--- | :--- | :--- | :--- |
| **集合运算符** | $R \ ∪ \ S$ | 并 (Union) | `UNION` | **合并清单** | 结果包含所有在$R$或$S$或两者中的**元组**（去重）： $\{ t \mid t \in R \ ∨ \ t \in S \}$ |
| | $R \ ∩ \ S$ | 交 (Intersection) | `INTERSECT` | **找共同项** | 结果包含所有同时属于$R$和$S$的元组： $\{ t \mid t \in R \ ∧ \ t \in S \}$ |
| | $R \ - \ S$ | 差 (Difference) | `EXCEPT` | **划掉已有项** | 结果包含所有在$R$中但**不在**$S$中的元组： $\{ t \mid t \in R \ ∧ \ t \notin S \}$ |
| | $R \ × \ S$ | 笛卡尔积 (Cartesian Product) | `CROSS JOIN` | **全能组合** | 结果包含$R$中每个元组与$S$中每个元组的**所有可能组合**。 |
| **专门关系运算符** | $\partial_{condition}(R)$ | 选择 (Selection) | `WHERE` | **横向筛选（挑行）** | 从关系$R$中选出满足条件$condition$的元组： $\{ t \mid t \in R \ ∧ \ condition(t) \}$ |
| | $\pi_{A_1, A_2, ..., A_k}(R)$ | 投影 (Projection) | `SELECT` (指定列时) | **纵向筛选（选列）** | 从关系$R$中提取指定属性列$A_1, A_2, ..., A_k$，并**去除重复元组**。 |
| | $R \ ∞ \ S$ <br> $R \ ∞_{\theta} \ S$ | 连接 (Join) <br> 条件连接 | `JOIN ... ON` <br> `NATURAL JOIN` | **智能拼接** | **自然连接**: 在所有同名属性上等值连接 <br> **θ-连接**: $R \ ∞_{\theta} S = \partial_{\theta}(R \ × \ S)$ |
| | $R \ ÷ \ S$ | 除 (Division) | 通过 `NOT EXISTS` 子查询实现 | **查询“全部”** | 解决“对所有...”查询。设$R(X, Y)$，$S(Y)$，则 $R \ ÷ \ S = \{ t_X \mid \forall t_S \in S, (t_X, t_S) \in R \}$ |
| **逻辑运算符** | $P \ ∧ \ Q$ | 与 (And) | `AND` | **并且** | 逻辑与，连接条件。 |
| | $P \ ∨ \ Q$ | 或 (Or) | `OR` | **或者** | 逻辑或，连接条件。 |
| | $¬ \ P$ | 非 (Not) | `NOT` | **不是** | 逻辑非，取反。 |

---

### **使用您提供符号的严谨表达式示例**

> **例1：查询计算机系男生的姓名**
$$
\pi_{Sn}(\partial_{Sd='CS' \ ∧ \ Sg='M'}(Student))
$$

**对应SQL：**

```sql
SELECT Sn FROM Student WHERE Sd = 'CS' AND Sg = 'M';
```

> **例2：查询选修了课程C1的学生姓名**
$$
\pi_{Sn}(\partial_{C\#='C1'}(SC) \ ∞ \ Student)
$$

**对应SQL：**

```sql
SELECT S.Sn 
FROM SC JOIN Student S ON SC.S# = S.S# 
WHERE SC.C# = 'C1';
```

> **例3：查询选修了全部课程的学生学号**
$$
\pi_{S\#, C\#}(SC) \ ÷ \ \pi_{C\#}(Course)
$$

**对应SQL：**

```sql
SELECT DISTINCT S# FROM SC S1
WHERE NOT EXISTS (
    SELECT C# FROM Course
    WHERE NOT EXISTS (
        SELECT * FROM SC S2 
        WHERE S2.S# = S1.S# AND S2.C# = Course.C#
    )
);
```

## Deepseek睡前故事

## 用人类友好的方式解释一下 "笛卡尔积 选择 投影 链接"

### **普通人如何“看”表格 vs. 数据库如何“操作”表格**

作为一个咖啡馆老板，当你看着Excel里的**订单表**时，你的大脑是这样工作的：

* **整体扫描**：你的视线会快速扫过整个表格，行列信息同时涌入脑海。你可能会先看标题行，然后顺着某一行读下去，了解一个完整订单的所有信息。
* **模式识别**：你一眼就能看到“张三”这个名字在“顾客名”这一列里出现了好几次。
* **关联思考**：当你在订单表里看到“顾客ID: 101”，你的大脑会本能地联想到：“哦，101就是那个爱坐角落的张先生”。你已经在潜意识里完成了**连接**操作。

**这是一种二维的、并行处理的人类智能。**

现在，让我们看看数据库（关系代数）是如何“看”这张表的。它不是一个有智慧的生物，而是一个**极其精准但“刻板”的机械臂系统**。它永远在“盲操作”。

---

### **咖啡馆的“机械臂”分拣系统**

想象你的仓库里有一个**盲操作的机械臂**和一条**传送带**。表格的每一行（一个订单记录）就是一个放在传送带上的**文件袋**，袋子上贴着标签（行数据），里面装着这个订单的所有资料（列数据）。

#### **1. 投影：机械臂的“取物夹”**

* **你的指令**：“我只想知道所有订单的【顾客名】和【饮品】。”
* **机械臂操作**：
  * 机械臂**看不到**文件袋里有什么。它必须拿起每一个文件袋，打开。
  * 然后，它配备了一个**只夹取特定纸张**的“取物夹”。这个夹子只会夹出“顾客名”和“饮品”这两张纸。
  * 最后，它把这两张纸放入一个新的、更薄的文件袋，放到另一条传送带上。
  * **关键区别**：你作为人，可以一眼锁定“顾客名”这一列。而机械臂必须**处理每一行**，并**纵向地**从每一行中剥离出不需要的列。**投影是纵向的、针对列的操作，但它必须作用于每一行来实现。**

#### **2. 选择：机械臂的“检测器”**

* **你的指令**：“把所有【金额大于30元】的订单找出来。”
* **机械臂操作**：
  * 传送带经过一个“检测门”，这个门只检测文件袋标签上“金额”这个值。
  * 如果金额>30，检测门亮绿灯，文件袋继续传送到“大额订单”区域。
  * 如果金额<=30，检测门亮红灯，一个推杆会把文件袋推落到“普通订单”筐里。
  * **关键区别**：你一眼就能在表格里高亮所有金额大于30的行。而机械臂必须**逐行、横向地**进行判断和筛选。**选择是横向的、针对行的过滤。**

#### **3. 连接：机械臂的“配对站”**

* **你的指令**：“把订单和下单顾客的电话号码匹配起来。”
* **机械臂操作**：
  * 现在有两条传送带：一条是**订单文件袋**（里面有顾客ID），另一条是**顾客文件袋**（里面有顾客ID和电话）。
  * 配对站的工作是：拿起一个**订单文件袋**，读出它的“顾客ID”，比如是“101”。
  * 然后它在**顾客文件袋**的堆栈里，疯狂地翻找标签上顾客ID也是“101”的那个文件袋。
  * 找到后，它把顾客文件袋里的“电话号码”纸条**复印一份**，和订单文件袋里的所有纸条**装订在一起**，形成一个新的、更厚的文件袋。
  * **关键区别**：你作为人，可以同时在两张大表上找到“101”这个信息并建立联系。而机械臂是在**盲目地、一对一地进行匹配和拼接**。它不知道“101”是谁，它只执行规则。

#### **4. 笛卡尔积：机械臂的“暴力复印机”**

* **你的指令**：（通常你不会直接下这个指令）“把每个顾客和每种饮品都组合一遍。”
* **机械臂操作**：
  * 复印机拿起**顾客表**的每一个文件袋（张三、李四）。
  * 对于“张三”这个文件袋，它把它分别和**饮品单**的每一个文件袋（美式、拿铁、奶茶）**复印并装订在一起**，得到（张三-美式，张三-拿铁，张三-奶茶）三个新文件袋。
  * 然后对“李四”重复上述操作。
  * **关键区别**：这会产生大量**无意义**的组合（比如李四可能从不喝奶茶）。你作为人绝不会这么干，但这是机械臂执行某些复杂任务（如连接）时，可能发生的**原始、笨拙的第一步**。

### **结论**

所以，区别在于：

* **普通人看表**：是**二维的、整体的、智能的、关联的**。你一眼就能获取行列信息并理解其含义。
* **数据库操作表**：是**一维的、序列化的、机械的、盲操作的**。它把表格看作一系列独立的行（元组），通过一条简单的指令流（关系代数），对这些行进行**纵向裁剪（投影）**、**横向过滤（选择）** 和**横向拼接（连接）**。

---

未提供算术比较符版本,算术比较符版本人类易读性较高
